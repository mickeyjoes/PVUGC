//! Contains the CRS and the functionality a trusted party can use to generate it.
//!
//! The Common Reference String (CRS) for Groth-Sahai consists of a commitment keypair `(u, v)` and
//! the bilinear group generators `(g1, g2, gt)`.
//!
//! - As per [[GSW '10]](https://www.iacr.org/archive/pkc2010/60560179/60560179.pdf), the CRS
//!   should either be generated by a trusted party or through some other form of trusted
//!   computation as a binding key for a real system.
//! - The committment keys `u` and `v` should be computationally indistinguishable
//!   under the SXDH assumption as to whethere they were instantiated as a:
//!    1) Perfect soundness string (i.e. perfectly binding), or
//!    2) Composable witness-indistinguishability string (i.e. perfectly hiding)

use crate::data_structures::{Com1, Com2};

use ark_ec::{
    pairing::{Pairing, PairingOutput},
    CurveGroup, AffineRepr,
};
use ark_ff::{UniformRand, Zero, Field, One};
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use ark_std::{ops::Mul, rand::Rng};

/// An abstract trait for denoting how to generate a CRS
pub trait AbstractCrs<E: Pairing> {
    /// Generates the keys `u` for committing `G1` and `Fr` to
    /// [`B1`](crate::data_structures::B1) and `v` for committing `G2` and `Fr` to
    /// [`B2`](crate::data_structures::B2).
    fn generate_crs<R>(rng: &mut R) -> Self
    where
        R: Rng;
}

/// Contains the commitment keys and bilinear group generators
#[derive(Clone, Debug, CanonicalSerialize, CanonicalDeserialize)]
pub struct CRS<E: Pairing> {
    pub u: Vec<Com1<E>>,
    pub v: Vec<Com2<E>>,
    pub g1_gen: E::G1Affine,
    pub g2_gen: E::G2Affine,
    pub gt_gen: PairingOutput<E>,
}

impl<E: Pairing> CRS<E> {
    // Returns intermediate "second" values that are used to construct un-blinded (i.e. binding) committment keys
    #[inline(always)]
    #[allow(unused_variables)]
    fn prepare_real_binding_key(
        g1_gen: E::G1,
        g2_gen: E::G2,
        q1: E::G1,
        t1: E::ScalarField,
        q2: E::G2,
        t2: E::ScalarField,
    ) -> (E::G1, E::G2) {
        // NOTE: v1 and v2 should be the only difference between a blinding and a hiding key
        let v1 = q1.mul(t1) - E::G1::zero();
        let v2 = q2.mul(t2) - E::G2::zero();
        (v1, v2)
    }

    // Returns intermediate "second" values that are used to construct blinded (i.e. hiding) committment keys
    #[inline(always)]
    #[allow(dead_code)]
    fn prepare_simulated_hinding_key(
        g1_gen: E::G1,
        g2_gen: E::G2,
        q1: E::G1,
        t1: E::ScalarField,
        q2: E::G2,
        t2: E::ScalarField,
    ) -> (E::G1, E::G2) {
        // NOTE: v1 and v2 should be the only difference between a blinding and a hiding key
        let v1 = q1.mul(t1) - g1_gen;
        let v2 = q2.mul(t2) - g2_gen;
        (v1, v2)
    }
}

impl<E: Pairing> AbstractCrs<E> for CRS<E> {
    fn generate_crs<R>(rng: &mut R) -> CRS<E>
    where
        R: Rng,
    {
        // Generators for G1 and G2
        let p1 = E::G1::rand(rng);
        let p2 = E::G2::rand(rng);

        // Scalar intermediate values
        let a1 = E::ScalarField::rand(rng);
        let a2 = E::ScalarField::rand(rng);
        let t1 = E::ScalarField::rand(rng);
        let t2 = E::ScalarField::rand(rng);

        // Projective intermediate values
        let q1 = p1.mul(a1);
        let q2 = p2.mul(a2);
        let u1 = p1.mul(t1);
        let u2 = p2.mul(t2);

        let (v1, v2) = Self::prepare_real_binding_key(p1, p2, q1, t1, q2, t2);

        // B1 commitment key for G1 and Fr
        let u11 = Com1::<E>(p1.into_affine(), q1.into_affine());
        let u12 = Com1::<E>(u1.into_affine(), v1.into_affine());

        // B2 commitment key for G2 and Fr
        let u21 = Com2::<E>(p2.into_affine(), q2.into_affine());
        let u22 = Com2::<E>(u2.into_affine(), v2.into_affine());

        CRS::<E> {
            u: vec![u11, u12],
            v: vec![u21, u22],
            g1_gen: p1.into_affine(),
            g2_gen: p2.into_affine(),
            gt_gen: E::pairing(p1.into_affine(), p2.into_affine()),
        }
    }
}

// === Extended CRS with duals (rank-2 / WI) ===
#[derive(Clone, Debug, CanonicalSerialize, CanonicalDeserialize)]
pub struct CRSWithDuals<E: Pairing> {
    pub crs: CRS<E>,
    // duals live in the opposite groups
    pub u_star: Vec<(E::G2Affine, E::G2Affine)>, // duals for u (G2 pairs)
    pub v_star: Vec<(E::G1Affine, E::G1Affine)>, // duals for v (G1 pairs)
}

impl<E: Pairing> CRSWithDuals<E> {
    /// Generate a WI (rank-2) CRS and exact duals (public)
    pub fn generate_wi_with_duals<R: Rng>(rng: &mut R) -> Self {
        let g1 = E::G1::rand(rng);
        let g2 = E::G2::rand(rng);

        // trapdoor scalars
        let a1 = E::ScalarField::rand(rng);
        let t1 = E::ScalarField::rand(rng);
        let a2 = E::ScalarField::rand(rng);
        let t2 = E::ScalarField::rand(rng);

        // WI rows: u = [(g1, a1*g1), (t1*g1, (a1*t1-1)*g1)]
        let u0  = g1.into_affine();
        let u0b = (g1 * a1).into_affine();
        let u1  = (g1 * t1).into_affine();
        let u1b = (g1 * (a1 * t1 - E::ScalarField::one())).into_affine();

        // WI rows: v = [(g2, a2*g2), (t2*g2, (a2*t2-1)*g2)]
        let v0  = g2.into_affine();
        let v0b = (g2 * a2).into_affine();
        let v1  = (g2 * t2).into_affine();
        let v1b = (g2 * (a2 * t2 - E::ScalarField::one())).into_affine();

        let crs = CRS::<E> {
            u: vec![Com1(u0, u0b), Com1(u1, u1b)],
            v: vec![Com2(v0, v0b), Com2(v1, v1b)],
            g1_gen: g1.into_affine(),
            g2_gen: g2.into_affine(),
            gt_gen: E::pairing(g1.into_affine(), g2.into_affine()),
        };

        // exact duals from U^{-1}, V^{-1} (det = -1)
        // U^{-1} = [[1 - a1 t1, a1],[t1, -1]]
        let u_star = vec![
            ((g2 * (E::ScalarField::one() - a1 * t1)).into_affine(), (g2 * t1).into_affine()),
            ((g2 * a1).into_affine(),                                (g2 * (-E::ScalarField::one())).into_affine()),
        ];
        // V^{-1} = [[1 - a2 t2, a2],[t2, -1]]
        let v_star = vec![
            ((g1 * (E::ScalarField::one() - a2 * t2)).into_affine(), (g1 * t2).into_affine()),
            ((g1 * a2).into_affine(),                                (g1 * (-E::ScalarField::one())).into_affine()),
        ];

        CRSWithDuals { crs, u_star, v_star }
    }
}

#[cfg(test)]
mod tests {
    use ark_bls12_381::Bls12_381 as F;
    use ark_ec::{pairing::Pairing, AffineRepr, CurveGroup};
    use ark_ff::Zero;
    use ark_std::test_rng;

    use super::*;

    type G1Projective = <F as Pairing>::G1;
    type G1Affine = <F as Pairing>::G1Affine;
    type G2Projective = <F as Pairing>::G2;
    type G2Affine = <F as Pairing>::G2Affine;
    type GT = PairingOutput<F>;
    type Fr = <F as Pairing>::ScalarField;

    #[test]
    fn test_valid_generators() {
        let mut rng = test_rng();

        let crs = CRS::<F>::generate_crs(&mut rng);

        // Generator for GT is e(g1,g2)
        assert_eq!(crs.gt_gen, F::pairing(crs.g1_gen, crs.g2_gen));
        // Non-degeneracy of bilinear pairing will hold
        assert_ne!(crs.g1_gen, G1Affine::zero());
        assert_ne!(crs.g2_gen, G2Affine::zero());
        assert_ne!(crs.gt_gen, GT::zero());
    }

    #[test]
    fn test_wi_rank2_duals() {
        let mut rng = test_rng();
        
        // Generate WI CRS with duals
        let crs_with_duals = CRSWithDuals::<F>::generate_wi_with_duals(&mut rng);
        
        // Check basic structure
        assert_eq!(crs_with_duals.crs.u.len(), 2);
        assert_eq!(crs_with_duals.crs.v.len(), 2);
        assert_eq!(crs_with_duals.u_star.len(), 2);
        assert_eq!(crs_with_duals.v_star.len(), 2);
        
        // Check that duals are in opposite groups
        // u_star should be G2 pairs (duals of u which are G1)
        // v_star should be G1 pairs (duals of v which are G2)
        for (a, b) in &crs_with_duals.u_star {
            assert_ne!(*a, G2Affine::zero());
            assert_ne!(*b, G2Affine::zero());
        }
        for (a, b) in &crs_with_duals.v_star {
            assert_ne!(*a, G1Affine::zero());
            assert_ne!(*b, G1Affine::zero());
        }
        
        // Test dual orthogonality: u_i · u_star_j = δ_{ij} * e(g1, g2)
        // where δ_{ij} is the Kronecker delta
        let gt_gen = crs_with_duals.crs.gt_gen;
        
        // Test u[0] · u_star[0] = e(g1, g2)
        let u0_pairing = F::pairing(crs_with_duals.crs.u[0].0, crs_with_duals.u_star[0].0) +
                        F::pairing(crs_with_duals.crs.u[0].1, crs_with_duals.u_star[0].1);
        assert_eq!(u0_pairing, gt_gen);
        
        // Test u[1] · u_star[1] = e(g1, g2)
        let u1_pairing = F::pairing(crs_with_duals.crs.u[1].0, crs_with_duals.u_star[1].0) +
                        F::pairing(crs_with_duals.crs.u[1].1, crs_with_duals.u_star[1].1);
        assert_eq!(u1_pairing, gt_gen);
        
        // Test u[0] · u_star[1] = 0 (orthogonality)
        let u0_u1_pairing = F::pairing(crs_with_duals.crs.u[0].0, crs_with_duals.u_star[1].0) +
                           F::pairing(crs_with_duals.crs.u[0].1, crs_with_duals.u_star[1].1);
        assert_eq!(u0_u1_pairing, GT::zero());
        
        // Test u[1] · u_star[0] = 0 (orthogonality)
        let u1_u0_pairing = F::pairing(crs_with_duals.crs.u[1].0, crs_with_duals.u_star[0].0) +
                           F::pairing(crs_with_duals.crs.u[1].1, crs_with_duals.u_star[0].1);
        assert_eq!(u1_u0_pairing, GT::zero());
        
        // Test v[0] · v_star[0] = e(g1, g2)
        let v0_pairing = F::pairing(crs_with_duals.v_star[0].0, crs_with_duals.crs.v[0].0) +
                        F::pairing(crs_with_duals.v_star[0].1, crs_with_duals.crs.v[0].1);
        assert_eq!(v0_pairing, gt_gen);
        
        // Test v[1] · v_star[1] = e(g1, g2)
        let v1_pairing = F::pairing(crs_with_duals.v_star[1].0, crs_with_duals.crs.v[1].0) +
                        F::pairing(crs_with_duals.v_star[1].1, crs_with_duals.crs.v[1].1);
        assert_eq!(v1_pairing, gt_gen);
        
        // Test v[0] · v_star[1] = 0 (orthogonality)
        let v0_v1_pairing = F::pairing(crs_with_duals.v_star[0].0, crs_with_duals.crs.v[1].0) +
                           F::pairing(crs_with_duals.v_star[0].1, crs_with_duals.crs.v[1].1);
        assert_eq!(v0_v1_pairing, GT::zero());
        
        // Test v[1] · v_star[0] = 0 (orthogonality)
        let v1_v0_pairing = F::pairing(crs_with_duals.v_star[1].0, crs_with_duals.crs.v[0].0) +
                           F::pairing(crs_with_duals.v_star[1].1, crs_with_duals.crs.v[0].1);
        assert_eq!(v1_v0_pairing, GT::zero());
        
        println!("✓ WI rank-2 duals test passed: dual orthogonality verified");
    }

    #[test]
    fn test_wi_rank2_matrix_inverse() {
        let mut rng = test_rng();
        
        // Generate WI CRS with duals
        let crs_with_duals = CRSWithDuals::<F>::generate_wi_with_duals(&mut rng);
        
        // Test that the duals are exact matrix inverses
        // For WI CRS: u = [(g1, a1*g1), (t1*g1, (a1*t1-1)*g1)]
        // The duals should be: u_star = [(g2*(1-a1*t1), g2*t1), (g2*a1, g2*(-1))]
        // This corresponds to U^{-1} = [[1 - a1 t1, a1],[t1, -1]]
        
        // We can't directly test matrix multiplication since we don't have the trapdoor scalars,
        // but we can test that the duals satisfy the orthogonality relationships
        
        // Test that u[0] · u_star[0] = e(g1, g2) and u[0] · u_star[1] = 0
        // This verifies that u_star[0] is orthogonal to u[1] and normalized with u[0]
        let u0_u0_star = F::pairing(crs_with_duals.crs.u[0].0, crs_with_duals.u_star[0].0) +
                        F::pairing(crs_with_duals.crs.u[0].1, crs_with_duals.u_star[0].1);
        let u0_u1_star = F::pairing(crs_with_duals.crs.u[0].0, crs_with_duals.u_star[1].0) +
                        F::pairing(crs_with_duals.crs.u[0].1, crs_with_duals.u_star[1].1);
        
        assert_eq!(u0_u0_star, crs_with_duals.crs.gt_gen);
        assert_eq!(u0_u1_star, GT::zero());
        
        // Test that u[1] · u_star[1] = e(g1, g2) and u[1] · u_star[0] = 0
        let u1_u1_star = F::pairing(crs_with_duals.crs.u[1].0, crs_with_duals.u_star[1].0) +
                        F::pairing(crs_with_duals.crs.u[1].1, crs_with_duals.u_star[1].1);
        let u1_u0_star = F::pairing(crs_with_duals.crs.u[1].0, crs_with_duals.u_star[0].0) +
                        F::pairing(crs_with_duals.crs.u[1].1, crs_with_duals.u_star[0].1);
        
        assert_eq!(u1_u1_star, crs_with_duals.crs.gt_gen);
        assert_eq!(u1_u0_star, GT::zero());
        
        // Test that the duals are non-zero and distinct
        assert_ne!(crs_with_duals.u_star[0].0, crs_with_duals.u_star[1].0);
        assert_ne!(crs_with_duals.u_star[0].1, crs_with_duals.u_star[1].1);
        assert_ne!(crs_with_duals.v_star[0].0, crs_with_duals.v_star[1].0);
        assert_ne!(crs_with_duals.v_star[0].1, crs_with_duals.v_star[1].1);
        
        println!("✓ WI rank-2 matrix inverse test passed: duals are exact inverses");
    }

    #[allow(non_snake_case)]
    #[test]
    fn test_valid_binding_CRS() {
        std::env::set_var("DETERMINISTIC_TEST_RNG", "1");
        let mut rng = test_rng();
        let mut rng2 = test_rng();

        let crs = CRS::<F>::generate_crs(&mut rng);

        // Follow the same process as necessary to prepare a binding key
        let p1 = G1Projective::rand(&mut rng2);
        let p2 = G2Projective::rand(&mut rng2);
        let a1 = Fr::rand(&mut rng2);
        let a2 = Fr::rand(&mut rng2);
        let t1 = Fr::rand(&mut rng2);
        let t2 = Fr::rand(&mut rng2);
        let q1 = p1.mul(a1);
        let q2 = p2.mul(a2);
        let (v1, v2) = CRS::<F>::prepare_real_binding_key(p1, p2, q1, t1, q2, t2);

        // Generated commitment keys are non-trivial
        assert_ne!(crs.u[0], Com1::zero());
        assert_ne!(crs.u[1], Com1::zero());
        assert_ne!(crs.v[0], Com2::zero());
        assert_ne!(crs.v[1], Com2::zero());

        // The chosen keys are binding (i.e. not hiding)
        assert_ne!(crs.g1_gen, G1Affine::zero());
        assert_ne!(crs.g2_gen, G2Affine::zero());
        assert_eq!(crs.u[1].1, v1.into_affine());
        assert_eq!(crs.v[1].1, v2.into_affine());
    }

    #[allow(non_snake_case)]
    #[test]
    fn test_CRS_serde() {
        let mut rng = test_rng();
        let crs = CRS::<F>::generate_crs(&mut rng);

        let mut c_bytes = Vec::new();
        crs.serialize_compressed(&mut c_bytes).unwrap();
        let crs_deserialized = CRS::<F>::deserialize_compressed(&c_bytes[..]).unwrap();
        assert_eq!(crs.u, crs_deserialized.u);
        assert_eq!(crs.v, crs_deserialized.v);
        assert_eq!(crs.g1_gen, crs_deserialized.g1_gen);
        assert_eq!(crs.g2_gen, crs_deserialized.g2_gen);
        assert_eq!(crs.gt_gen, crs_deserialized.gt_gen);

        let mut u_bytes = Vec::new();
        crs.serialize_uncompressed(&mut u_bytes).unwrap();
        let crs_deserialized = CRS::<F>::deserialize_uncompressed(&u_bytes[..]).unwrap();
        assert_eq!(crs.u, crs_deserialized.u);
        assert_eq!(crs.v, crs_deserialized.v);
        assert_eq!(crs.g1_gen, crs_deserialized.g1_gen);
        assert_eq!(crs.g2_gen, crs_deserialized.g2_gen);
        assert_eq!(crs.gt_gen, crs_deserialized.gt_gen);
    }
}
